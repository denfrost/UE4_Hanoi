// Fill out your copyright notice in the Description page of Project Settings.


#include "MoveSequence.h"
#include "Kismet/GameplayStatics.h"
#include <algorithm>

bool OneMove::MoveDelta(float DeltaTime)
{
    //UE_LOG(LogTemp, Warning, TEXT("Delta: %f"), DeltaTime);
    TotalTime += DeltaTime;
    if(TotalTime <= T1)
    {
        FVector Pos = V_Begin + Start_T1 * TotalTime;
        CurrentPlate->SetActorLocation(Pos);
        return false;
    }
    else if(TotalTime <= T2)
    {
        FVector Pos = V_BeginTop + T1_T2 * (TotalTime - T1);
        CurrentPlate->SetActorLocation(Pos);
        return false;
    }
    else if(TotalTime < 1.0f)
    {
        FVector Pos = V_EndTop + T2_End * (TotalTime - T2);
        CurrentPlate->SetActorLocation(Pos);
        return false;
    }
    else
    {
        CurrentPlate->Mesh->SetSimulatePhysics(true);
        CurrentPlate->Mesh->SetEnableGravity(true);
        CurrentPlate->SetActorLocation(V_End);
        return true;
    }
}

MoveSequence::MoveSequence()
{
}

MoveSequence::~MoveSequence()
{
}

void MoveSequence::SetPoles(APole* PA, APole* PB, APole* PC)
{
    this->PoleA = PA;
    this->PoleB = PB;
    this->PoleC = PC;
    bInited = (PoleA && PoleB && PoleC);
    if(!bInited)
    {
        UE_LOG(LogTemp, Warning, TEXT("INIT ERROR"));
    }
    // generated by script
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleA));
    All.emplace_back(std::make_pair(PoleC, PoleA));
    All.emplace_back(std::make_pair(PoleB, PoleC));
    All.emplace_back(std::make_pair(PoleA, PoleB));
    All.emplace_back(std::make_pair(PoleA, PoleC));
    All.emplace_back(std::make_pair(PoleB, PoleC));

    std::reverse(All.begin(), All.end());
    NextMove();
}

void MoveSequence::RunInTick(float DeltaTime)
{
    if(!bInited || bFinished || !CurrentMove)
    {
        return;
    }
    
    if(CurrentMove->MoveDelta(DeltaTime))
    {
        NextMove();
    }
}

void MoveSequence::NextMove()
{
    if(All.empty())
    {
        bFinished = true;
        FTimerHandle UnusedHandle;
        FTimerDelegate UnusedDelegate;
        UnusedDelegate.BindLambda([this](){
            UGameplayStatics::OpenLevel(PoleA, FName(*PoleA->GetWorld()->GetName()), false);
        });
        PoleA->GetWorld()->GetTimerManager().SetTimer(UnusedHandle, UnusedDelegate, 3.0f, false);
        return;
    }
    
    auto p = All.back();
    CurrentMove = std::make_unique<OneMove>(p.first, p.second);
    All.pop_back();
}
